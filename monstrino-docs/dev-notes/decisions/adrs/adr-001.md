---
id: adr-001-shared-domain-packages
title: ADR-001 â€” Shared Domain Packages as Single Source of Truth
sidebar_label: ADR-001 Shared Domain Packages
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

> **Status:** Accepted  
> **Scope:** Cross-service architecture  
> **Audience:** Engineering / Architecture review

---

## Context

The system consists of multiple microservices that operate on the same domain concepts  
(releases, characters, series, images, relations).

Each service requires access to:

- domain data structures (DTOs),
- ORM mappings,
- repository interfaces,
- shared persistence logic.

A naÃ¯ve approach â€” duplicating these artifacts per service â€” introduced structural risks:

- schema changes required synchronized edits across many services,
- repository logic was copied and diverged over time,
- adding a new query or invariant caused repetitive boilerplate,
- refactoring database structure became increasingly expensive.

At this stage, the system already contained **10+ domain tables** and **multiple services**
interacting with overlapping subsets of the same data.

---

## Decision

Introduce **shared, versioned domain packages** that act as a **single source of truth**
for cross-service concerns.

### Introduced packages

- **`monstrino-models`**
  - SQLAlchemy ORM models
  - Pydantic DTOs

- **`monstrino-repositories`**
  - repository interfaces
  - base and CRUD repository implementations

- **`monstrino-core`**
  - shared domain primitives (enums, value objects, exceptions)

- **`monstrino-testing`**
  - shared fixtures and testing infrastructure

Services consume these packages via **explicit versioning** instead of duplicating code.

---

## Boundary Rules

:::info Strict Layering
The following constraints are intentionally enforced:
:::

- ORM models are **only allowed inside repositories**
- Application and use-case layers operate **exclusively on DTOs**
- Direct ORM access outside repositories is forbidden

This ensures clear ownership and prevents leakage of persistence concerns into business logic.

---

## Alternatives Considered

### 1. Full Duplication per Service

Each service maintains its own ORM, DTOs, and repositories.

:::danger Rejected
- High change amplification  
- Inevitable divergence of logic  
- Unsafe refactoring  
- Maintenance cost grows superlinearly with service count
:::

---

### 2. Shared Database with Thin Services

Centralize data access in one service and expose it to others.

:::danger Rejected
- Creates a hidden monolith  
- Couples services at runtime instead of compile time  
- Limits independent evolution and testing
:::

---

### 3. Code Generation from Schema

Generate DTOs and repositories automatically.

:::danger Rejected
- Introduces additional toolchain complexity  
- Harder to reason about ownership and evolution  
- Reduced transparency during refactors
:::

---

## Consequences

### âœ… Positive

- Single point of truth for domain structures
- Schema changes are applied once and versioned explicitly
- Repository logic is consistent across services
- Services remain focused on behavior, not infrastructure
- Enables independent service evolution via package versioning

---

### âš ï¸ Negative

- Requires strict discipline around package boundaries
- Shared packages must remain stable and conservative
- Package versioning introduces coordination overhead
- Errors in shared packages have a wider blast radius

---

### ðŸŽ¯ Accepted Trade-off

The system prefers:

> **compile-time coupling via shared packages**  
> over  
> **runtime coupling via service-to-service data access**

This trades stricter version control for architectural clarity and refactor safety.

---

## Notes for Reviewers

:::note
This decision was driven by **development scalability and maintainability**,  
not by runtime performance optimization.

The approach intentionally favors **explicit structure and refactor safety**
over short-term convenience.
:::
