---
id: adr-003-parsed-tables-importer-boundary
title: ADR-003 â€” Parsed Tables and Importer as Data Boundary
sidebar_label: ADR-003 Parsed Tables & Importer
---

> **Status:** Accepted  
> **Scope:** Data ingestion & domain isolation  
> **Audience:** Engineering / Architecture review

---

## Context

The system ingests data from multiple external sources with heterogeneous structures,
varying data quality, and evolving schemas.

Directly persisting parsed external data into canonical domain tables would introduce
several risks:

- tight coupling between parsers and internal database schema,
- frequent breakage when domain models evolve,
- inability to safely store partially valid or ambiguous data,
- difficulty inspecting and correcting raw external input.

At the same time, parsers must remain lightweight and adaptable to changes in
external sources without forcing coordinated changes across the entire system.

---

## Decision

Introduce an explicit **data boundary** between external data ingestion and the
canonical domain model by splitting the pipeline into two stages:

1. **Parsed Tables**
2. **Importer / Processing Layer**

### Parsed Tables

- Store raw or minimally normalized external data
- Closely reflect the structure of source systems
- Allow nullable, flexible, and source-specific fields
- Are isolated from domain invariants and business rules

Examples:
- ParsedRelease
- ParsedCharacter
- ParsedSeries
- ParsedPet

---

### Importer Boundary

A dedicated importer service is responsible for:

- validating parsed data against domain rules,
- resolving relations and references,
- transforming parsed records into canonical domain entities,
- preventing invalid or ambiguous data from entering core tables.

Parsers **never** write to canonical tables directly.

---

## Processing Model

```text
External Source
      â†“
Parser
      â†“
Parsed Tables (raw / flexible)
      â†“
Importer / Processor
      â†“
Canonical Domain Tables
```

This separation creates a clear and enforceable boundary between
external uncertainty and internal consistency.

---

## Alternatives Considered

### 1. Direct Write from Parser to Domain Tables

Parsers persist data directly into canonical tables.

:::danger Rejected
- Parsers become tightly coupled to internal schema
- Domain changes force parser rewrites
- Partial or invalid data pollutes canonical tables
- Hard to inspect raw external input after failures
:::

---

### 2. Parser-Specific Canonical Tables

Maintain separate canonical tables per source.

:::danger Rejected
- Schema explosion
- Complex cross-source reconciliation
- Increased query and maintenance complexity
- Difficult to present a unified domain view
:::

---

## Consequences

### âœ… Positive

- Canonical domain tables remain clean and invariant-driven
- Parsers can evolve independently of domain schema
- Raw external data remains inspectable and auditable
- Failed or ambiguous records are isolated before import
- Import logic is centralized and testable

---

### âš ï¸ Negative

- Increased number of tables and processing steps
- Additional transformation layer adds complexity
- Requires careful versioning of parsed schemas
- Slightly higher storage requirements

---

### ðŸŽ¯ Accepted Trade-off

The system intentionally prefers:

> **explicit data boundaries and transformation layers**  
> over  
> **shorter ingestion paths with implicit coupling**

This trades additional structural complexity for long-term
schema stability, debuggability, and domain integrity.

---

## Notes for Reviewers

:::note
Parsed tables are not considered part of the domain model.

They are treated as a durable ingestion buffer and inspection layer.
If source formats stabilize or ingestion requirements change,
this boundary can be revisited without impacting parsers or core tables.
:::